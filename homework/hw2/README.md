# Отчет по ДЗ №2: Финансовый трекер (CLI)

## a) Общая идея решения
Приложение — это простой консольный финансовый трекер, позволяющий:
- управлять счетами (создание, чтение, изменение, удаление);
- управлять категориями операций (доход/расход);
- добавлять, изменять и удалять финансовые операции;
- формировать отчет по состоянию на дату (список категорий и операций, сгруппированных по счетам);
- сохранять и загружать отчет в/из локального хранилища (JSON).

Ключевые элементы:
- Разделение на доменные сервисы и репозитории (чистая архитектура слоев);
- Транзакционный менеджер операций обновляет баланс счета при создании/изменении/удалении операции с откатами при ошибках;
- Генерация отчета построителем (Builder) для явного и расширяемого формирования объекта отчета;
- DI-контейнер (Koin) для инверсии зависимостей и удобной конфигурации компонентов.

Основные команды CLI реализованы в `CommandLineController` (см. help внутри приложения). Валидация бизнес‑правил: операция допустима только при существующем счете и категории, а также при совпадении типа категории и типа операции.

## b) SOLID и GRASP

SOLID
- SRP (Принцип единственной ответственности):
  - `AccountService`, `CategoryService`, `OperationService`, `ReportService` — каждый сервис отвечает за свою подсистему;
  - `JsonArgsParser` — отвечает только за парсинг входных аргументов;
  - `ReportBuilder` — отвечает только за пошаговую сборку отчета.
- OCP (Принцип открытости/закрытости):
  - Добавление новых реализаций `ReportRepository`, `ArgsParser`, `OperationRepository` не требует изменения клиентов — DI в `AppModule` подставит нужные биндинги;
  - Хранилища c посетителями (`StorageVisitable`, `StorageVisitor`) позволяют расширять поведение (логирование, аудит) без изменения базовой логики хранения.
- LSP (Подстановка Барбары Лисков):
  - Все реализации `AccountRepository`, `CategoryRepository`, `OperationRepository` взаимозаменяемы через интерфейсы доменного слоя.
- ISP (Принцип разделения интерфейсов):
  - Отдельные узкие интерфейсы репозиториев: `AccountRepository`, `CategoryRepository`, `OperationRepository`.
- DIP (Принцип инверсии зависимостей):
  - Сервисы зависят от абстракций (интерфейсов репозиториев), связывание с конкретными реализациями выполняет DI‑модуль `AppModule`.

GRASP
- Controller (Контроллер):
  - `CommandLineController` — центральная точка обработки команд пользователя, делегирует работу сервисам.
- Information Expert (Информационный эксперт):
  - `OperationTransactionManager` и `OperationService` принимают решения, имея доступ к нужным данным (операции, счета, категории);
  - `ReportService` агрегирует данные для отчета, так как имеет доступ к операциям и категориям.
- Creator (Создатель):
  - `ReportBuilder` создаёт экземпляр `Report` из предоставленных данных;
  - Репозитории создают/возвращают доменные сущности.
- Low Coupling / High Cohesion (Низкая связность / Высокая связность):
  - Модули имеют чёткие обязанности; зависимости инвертированы через DI;
  - Транзакционная логика изолирована в `OperationTransactionManager`, не расползается по сервисам/репозиториям.
- Indirection (Посредничество):
  - DI‑контейнер (`AppModule`) отделяет клиентов от конкретных реализаций;
  - Посетители в слое хранения отделяют расширения (аудит/логирование) от логики хранения.
- Polymorphism (Полиморфизм):
  - Замена реализаций репозиториев/парсеров/хранилищ происходит через интерфейсы.
- Protected Variations (Защищённые вариации):
  - Использование интерфейсов и DI защищает от изменений конкретных реализаций (например, переход от in‑memory к JSON/БД).

## c) Применённые паттерны GoF
- Builder (Строитель):
  - `builder/ReportBuilder` формирует `Report` пошагово (`withCategories`, `withAccountsAndOperations`, `build()`). Важно для расширяемости генерации отчета (можно добавлять новые шаги без модификации клиента) и читаемости кода.


- Decorator / Proxy (Декоратор/Прокси) для репозитория операций:
  - `domain/service/OperationTransaction.kt` содержит `OperationTransactionManager`, который реализует `OperationRepository`, делегирует базовой реализации и оборачивает вызовы транзакционной логикой (пересчет баланса, откаты при сбоях). Это классический пример прокси/декоратора над репозиторием с дополнительной ответственностью.

- Visitor (Посетитель) для событий хранилища:
  - `storage/StorageVisitor`, `storage/StorageVisitable`, а также конкретные `AccountsVisitor`, `CategoriesVisitor`, `OperationsVisitor`.
  - Обоснование: позволяет добавлять кросс‑резаные поведения (логирование, аудит, метрики) при операциях add/get/update/remove без изменения классов хранилища.

- Strategy (Стратегия):
  - `parser/ArgsParser` и его реализация `JsonArgsParser`; `data/ReportRepository` c реализацией `JsonReportRepository`; а также интерфейсы доменного слоя для доступа к данным (`domain/repository/*Repository.kt`) рассматриваются как стратегии хранения/доступа к данным (in-memory, файл и т.д.).
  - Обоснование: взаимозаменяемые алгоритмы парсинга и стратегии доступа/сохранения данных подставляются через интерфейсы и DI, что соответствует паттерну Стратегия.

- Facade (Фасад):
  - `domain/service/ReportService` скрывает детали получения категорий/операций, построения отчета и работы с локальным хранилищем. Клиенту предоставляется простой API: `generateReport`, `saveReport`, `loadReport`.

Дополнительно (не GoF, но архитектурно важно):
- Dependency Injection (через Koin): `di/AppModule` — композиционный корень приложения.

## Где что находится (навигатор по модулям)
- Точка входа: `src/main/kotlin/Application.kt`.
- DI‑конфигурация: `di/AppModule.kt`.
- Контроллер CLI: `controller/CommandLineController.kt`.
- Доменные сервисы: `domain/service/*.kt`.
- Интерфейсы репозиториев: `domain/repository/*.kt`.
- Реализации репозиториев: `repository/InMemory*.kt`, `data/json/JsonReportRepository.kt`.
- Модели: `models/*.kt`.
- Генерация отчета: `builder/ReportBuilder.kt`, `domain/service/ReportService.kt`.
- Слой хранения и посетители: `storage/*.kt`.
- Парсинг аргументов: `parser/*.kt`.

## Готовые JSON-шаблоны (удобно копировать при вводе команд)
Ниже — минимальные и полные примеры JSON для сущностей. Их можно сразу вставлять в команды `create-*`/`modify-*`/`get-*`/`delete-*` из консоли приложения.

Общие правила:
- `id` можно не указывать при создании — он сгенерируется автоматически. Для изменения/удаления — обязателен.
- `type` для категорий/операций: `INCOME` или `EXPENSE` (регистр не важен: включён decodeEnumsCaseInsensitive).
- Денежные суммы (`Amount.value`) указываются в минимальных единицах (копейки/центы): 12345 = 123.45.
- `date` для операции — в формате ISO‑8601, например: `"2025-01-31T12:00:00Z`". Если не указать — подставится текущее время.

1) Account (счёт)
 Минимальный:
 ```json5
{
  name: "Tinkoff",
  balance: 250000
}
 ```
 Примеры команд внутри приложения:
  - Создать: `create-account {name:Tinkoff,balance:250000}`
  - Изменить: `modify-account {id:<ID>,name:New,balance:100}`
  - Получить: `get-account <ID>`
  - Удалить: `delete-account <ID>`

2) Category (категория)
 Минимальный (для создания):
 ```json5
{
   type: "INCOME",
   name: "Salary"
}
 ```
 Примеры команд:
   - Создать: `create-category {type:income,name:Salary}`
   - Изменить: `modify-category {id:<ID>,type:income,name:Food}` - не получится изменить тип категории
   - Получить: `get-category <ID>`
   - Удалить: `delete-category <ID>`

3) Operation (операция)
 - Минимальный (для создания):
```json5
{
  type: "EXPENSE",
  bankAccountId: "<ACCOUNT_ID>",
  amount: 15990,
  description: "Coffee machine",
  categoryId: "<CATEGORY_ID>"
}
 ```
 - Примеры команд:
   - Создать: `create-operation {type:expense,bankAccountId:<ACCOUNT_ID>,amount:389,description:Coffee,categoryId:<CATEGORY_ID>}`
   - Изменить: `modify-operation {id:<ID>,type:income,bankAccountId:<ACCOUNT_ID>,amount:120000,description:Salary,categoryId:<CATEGORY_ID>}`
   - Получить: `get-operation <ID>`
   - Удалить: `delete-operation <ID>`

## Информация
- Внутри приложения доступна команда `help` для списка команд.
